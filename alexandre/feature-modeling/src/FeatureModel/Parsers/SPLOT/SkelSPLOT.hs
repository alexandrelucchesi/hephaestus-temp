module FeatureModel.Parsers.SPLOT.SkelSPLOT where

-- Haskell module generated by the BNF converter

import FeatureModel.Parsers.SPLOT.AbsSPLOT
import FeatureModel.Parsers.SPLOT.ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident str  -> failure x


transSPLOTModel :: SPLOTModel -> Result
transSPLOTModel x = case x of
  SPLOT featuremodel  -> failure x


transFeatureModel :: FeatureModel -> Result
transFeatureModel x = case x of
  FeatureModel feature constraints  -> failure x


transFeature :: Feature -> Result
transFeature x = case x of
  Feature fname childs  -> failure x


transChild :: Child -> Result
transChild x = case x of
  SetRelation fname cardinality groupedfeatures  -> failure x
  BinRelation cardinality solitaryfeature  -> failure x


transGroupedFeature :: GroupedFeature -> Result
transGroupedFeature x = case x of
  GroupedFeature fname childs  -> failure x
  LGroupedFeature fname  -> failure x


transSolitaryFeature :: SolitaryFeature -> Result
transSolitaryFeature x = case x of
  SolitaryFeature fname childs  -> failure x
  LSolitaryFeature fname  -> failure x


transCardinality :: Cardinality -> Result
transCardinality x = case x of
  Cardinality n0 n  -> failure x


transConstraint :: Constraint -> Result
transConstraint x = case x of
  Require fname0 fname1 fname  -> failure x
  Exclude fname0 fname1 fname  -> failure x


transFName :: FName -> Result
transFName x = case x of
  FName1 id  -> failure x
  FName2 id  -> failure x



